<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1" />
<meta name="generator" content="pdoc 0.7.4" />
<title>Rover_Source_Code.Pre_Generate.pre_generate_main_script API documentation</title>
<meta name="description" content="" />
<link href='https://cdnjs.cloudflare.com/ajax/libs/normalize/8.0.0/normalize.min.css' rel='stylesheet'>
<link href='https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/8.0.0/sanitize.min.css' rel='stylesheet'>
<link href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/styles/github.min.css" rel="stylesheet">
<style>.flex{display:flex !important}body{line-height:1.5em}#content{padding:20px}#sidebar{padding:30px;overflow:hidden}.http-server-breadcrumbs{font-size:130%;margin:0 0 15px 0}#footer{font-size:.75em;padding:5px 30px;border-top:1px solid #ddd;text-align:right}#footer p{margin:0 0 0 1em;display:inline-block}#footer p:last-child{margin-right:30px}h1,h2,h3,h4,h5{font-weight:300}h1{font-size:2.5em;line-height:1.1em}h2{font-size:1.75em;margin:1em 0 .50em 0}h3{font-size:1.4em;margin:25px 0 10px 0}h4{margin:0;font-size:105%}a{color:#058;text-decoration:none;transition:color .3s ease-in-out}a:hover{color:#e82}.title code{font-weight:bold}h2[id^="header-"]{margin-top:2em}.ident{color:#900}pre code{background:#f8f8f8;font-size:.8em;line-height:1.4em}code{background:#f2f2f1;padding:1px 4px;overflow-wrap:break-word}h1 code{background:transparent}pre{background:#f8f8f8;border:0;border-top:1px solid #ccc;border-bottom:1px solid #ccc;margin:1em 0;padding:1ex}#http-server-module-list{display:flex;flex-flow:column}#http-server-module-list div{display:flex}#http-server-module-list dt{min-width:10%}#http-server-module-list p{margin-top:0}.toc ul,#index{list-style-type:none;margin:0;padding:0}#index code{background:transparent}#index h3{border-bottom:1px solid #ddd}#index ul{padding:0}#index h4{font-weight:bold}#index h4 + ul{margin-bottom:.6em}@media (min-width:200ex){#index .two-column{column-count:2}}@media (min-width:300ex){#index .two-column{column-count:3}}dl{margin-bottom:2em}dl dl:last-child{margin-bottom:4em}dd{margin:0 0 1em 3em}#header-classes + dl > dd{margin-bottom:3em}dd dd{margin-left:2em}dd p{margin:10px 0}.name{background:#eee;font-weight:bold;font-size:.85em;padding:5px 10px;display:inline-block;min-width:40%}.name:hover{background:#e0e0e0}.name > span:first-child{white-space:nowrap}.name.class > span:nth-child(2){margin-left:.4em}.inherited{color:#999;border-left:5px solid #eee;padding-left:1em}.inheritance em{font-style:normal;font-weight:bold}.desc h2{font-weight:400;font-size:1.25em}.desc h3{font-size:1em}.desc dt code{background:inherit}.source summary,.git-link-div{color:#666;text-align:right;font-weight:400;font-size:.8em;text-transform:uppercase}.source summary > *{white-space:nowrap;cursor:pointer}.git-link{color:inherit;margin-left:1em}.source pre{max-height:500px;overflow:auto;margin:0}.source pre code{font-size:12px;overflow:visible}.hlist{list-style:none}.hlist li{display:inline}.hlist li:after{content:',\2002'}.hlist li:last-child:after{content:none}.hlist .hlist{display:inline;padding-left:1em}img{max-width:100%}.admonition{padding:.1em .5em;margin-bottom:1em}.admonition-title{font-weight:bold}.admonition.note,.admonition.info,.admonition.important{background:#aef}.admonition.todo,.admonition.versionadded,.admonition.tip,.admonition.hint{background:#dfd}.admonition.warning,.admonition.versionchanged,.admonition.deprecated{background:#fd4}.admonition.error,.admonition.danger,.admonition.caution{background:lightpink}</style>
<style media="screen and (min-width: 700px)">@media screen and (min-width:700px){#sidebar{width:30%}#content{width:70%;max-width:100ch;padding:3em 4em;border-left:1px solid #ddd}pre code{font-size:1em}.item .name{font-size:1em}main{display:flex;flex-direction:row-reverse;justify-content:flex-end}.toc ul ul,#index ul{padding-left:1.5em}.toc > ul > li{margin-top:.5em}}</style>
<style media="print">@media print{#sidebar h1{page-break-before:always}.source{display:none}}@media print{*{background:transparent !important;color:#000 !important;box-shadow:none !important;text-shadow:none !important}a[href]:after{content:" (" attr(href) ")";font-size:90%}a[href][title]:after{content:none}abbr[title]:after{content:" (" attr(title) ")"}.ir a:after,a[href^="javascript:"]:after,a[href^="#"]:after{content:""}pre,blockquote{border:1px solid #999;page-break-inside:avoid}thead{display:table-header-group}tr,img{page-break-inside:avoid}img{max-width:100% !important}@page{margin:0.5cm}p,h2,h3{orphans:3;widows:3}h1,h2,h3,h4,h5,h6{page-break-after:avoid}}</style>
</head>
<body>
<main>
<article id="content">
<header>
<h1 class="title">Module <code>Rover_Source_Code.Pre_Generate.pre_generate_main_script</code></h1>
</header>
<section id="section-intro">
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">import pandas as pd
import sys
import os, sys, inspect
# below 3 lines add the parent directory to the path, so that SQL_functions can be found.
currentdir = os.path.dirname(os.path.abspath(inspect.getfile(inspect.currentframe())))
parentdir = os.path.dirname(currentdir)
parentdir = os.path.dirname(parentdir)
parentdir = os.path.dirname(parentdir)
sys.path.insert(0, parentdir)


class PreGenerateMainScript:
    &#34;&#34;&#34;This file controls the processes occurring prior to generating latex files. Raw data -&gt; Processed data.&#34;&#34;&#34;

    def __init__(self, data_xml_file):
        &#34;&#34;&#34;The main init function.

        1. data_xml_file = the raw xml data file produced by TargetLynx. This must be manually placed in the datafiles
        2. folder to be read by Rover. The name of it is passed to init.
        3. raw_xml_data_frame = the first DataFrame produced from the xml file. At this point, the data is not
        manipulated in any way.
        4. percentage_data_frame = changes: analytical concentration converted to percentage concentration.
        5. blank_data_frame = changes: only information from blanks.
        6. qc_data_frame = changes: only information from standards.
        7. samples_data_frame = changes: only information from samples and their dilutions.
        8. best_recovery_qc_data_frame = changes: all the standard data has been analyzed, and the best recoveries for
        each analyte have been selected for the new data frame, which consists of one samples&#39; worth of rows.
        9. min_value_blank_data_frame = changes: one axis data frame with the minimum value of each analyte from the
        blank_data_frame.&#34;&#34;&#34;

        self.data_xml_file = data_xml_file
        self.raw_xml_data_frame = pd.DataFrame()
        self.percentage_data_frame = pd.DataFrame()
        self.blank_data_frame = pd.DataFrame()
        self.qc_data_frame = pd.DataFrame()
        self.samples_data_frame = pd.DataFrame()
        self.best_recovery_qc_data_frame = pd.DataFrame()
        self.min_value_blank_data_frame = pd.DataFrame()

#       Range check dictionary - these are the high and low values for our curve. If area is smaller than the first
#       number, or larger than the second one, it is out of range. If that happens, the value needs to be swapped with
#       the corresponding value from the dilution.
        self.range_checker_dictionary = {1: [3065, 44880, &#39;ibuprofen&#39;],
                                         2: [127, 94400, &#39;CBDV&#39;],
                                         3: [64, 16896, &#39;CBDVA&#39;],
                                         4: [259, 103785, &#39;THCV&#39;],
                                         5: [259, 103785, &#39;CBGVA&#39;],  # copying THCV for now
                                         6: [100, 160995, &#39;CBD&#39;],
                                         7: [117, 80956, &#39;CBG&#39;],
                                         8: [100, 170668, &#39;CBDA&#39;],
                                         9: [100, 27050, &#39;CBN&#39;],
                                         10: [100, 22440, &#39;CBGA&#39;],
                                         11: [100, 15440, &#39;THCVA&#39;],
                                         12: [133.9, 203125, &#39;d9_THC&#39;],
                                         13: [163, 84959, &#39;d8_THC&#39;],
                                         14: [86.4, 82725, &#39;CBL&#39;],
                                         15: [100, 14365, &#39;CBC&#39;],
                                         16: [131, 24365, &#39;CBNA&#39;],
                                         17: [100, 170391, &#39;THCA&#39;],
                                         18: [110, 20391, &#39;CBLA&#39;],
                                         19: [100, 12482, &#39;CBCA&#39;]}

#       This DataFrame is so we can join the calibration curve data to the samples DataFrame in order to flag the
#       samples for being over the curve.
        self.over_curve_data = {&#39;id17&#39;: [1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19],
                                &#39;max_value&#39;: [44880, 94400, 16896, 103785, 103785, 160995, 80956, 170668,
                                              27050, 22440, 15440, 203125, 84959, 82725, 14365, 24365,
                                              170391, 20391, 12482]}
        self.over_curve_data_frame = pd.DataFrame(self.over_curve_data, columns=[&#39;id17&#39;, &#39;max_value&#39;])

#       This is for development - allows me to see the full DataFrame when i print to the console, rather than a
#       truncated version. This is useful for debugging purposes and ensuring that methods are working as intended.
        pd.set_option(&#39;display.max_rows&#39;, None)
        pd.set_option(&#39;display.max_columns&#39;, None)
        pd.set_option(&#39;display.width&#39;, None)
        pd.set_option(&#39;display.max_colwidth&#39;, -1)

    def pre_generate_controller(self):
        &#34;&#34;&#34;The main controller function. To run the methods that make up this class, this function is called.&#34;&#34;&#34;

        self.collect_data_from_xml_file()
        self.convert_analytical_concentration_to_percentage_concentration()
        self.split_into_blank_qc_and_sample_data_frame()
        self.combine_qc_into_one_data_set_with_highest_recovery_values()
        self.combine_blanks_into_one_data_set_with_lowest_percentage_concentration_values()
        self.join_over_curve_df_to_samples_df()
        self.assign_high_flag_to_sample_data()

    def collect_data_from_xml_file(self):
        &#34;&#34;&#34;Reads the xml data, saves it to a Pandas DataFrame.

        1. id15: the id in the batch. First standard/blank/sample is 1, second is 2, etc.
        2. sampleid: the sample number, or the name of the standard/blank.
        3. id17: the id of the particular analyte for the row.
        4. name20: the name of the particular analyte for the row.
        5. initamount: the mass, in grams, of the sample.
        6. area: the peak area of the analyte from the chromatogram.
        7. analconc: the concentration calculated by TargetLynx. This will improve after analyst peak integration.
        8. percrecovery: the percentage recovery of ibuprofen.
        9. type: Blank, QC, or analyte.

        there is a try/except statement that will catch an incorrect path/filename.&#34;&#34;&#34;

        try:
            raw_xml_data = pd.read_excel(self.data_xml_file,)
        except FileNotFoundError:
            print(&#34;ERROR: XML FILE NOT FOUND&#34;)
            print(str(self.data_xml_file) + &#34; cannot be found. Either the path to the xml_data_files folder is &#34; +
                  &#34;wrong, or the file doesn&#39;t exist.&#34;)
            print(&#34;SCRIPT EXITING.&#34;)
            sys.exit()
        self.raw_xml_data_frame = pd.DataFrame(raw_xml_data,
                                               columns=[&#39;id15&#39;,
                                                        &#39;sampleid&#39;,
                                                        &#39;id17&#39;,
                                                        &#39;name20&#39;,
                                                        &#39;initamount&#39;,
                                                        &#39;area&#39;,
                                                        &#39;analconc&#39;,
                                                        &#39;percrecovery&#39;,
                                                        &#39;type&#39;]
                                               )

    def convert_analytical_concentration_to_percentage_concentration(self):
        &#34;&#34;&#34;converts the analytical concentration to a percent concentration. Saves as a new DataFrame.&#34;&#34;&#34;

        self.percentage_data_frame = self.raw_xml_data_frame
        self.percentage_data_frame[&#39;percentage_concentration&#39;] = self.percentage_data_frame[&#39;analconc&#39;]/10000

    def split_into_blank_qc_and_sample_data_frame(self):
        &#34;&#34;&#34;splits the percentage DataFrame into blank, qc, and sample DataFrames, based on the &#39;type&#39; column.&#34;&#34;&#34;

        self.blank_data_frame = self.percentage_data_frame[self.percentage_data_frame.type == &#34;Blank&#34;]
        self.qc_data_frame = self.percentage_data_frame[self.percentage_data_frame.type == &#34;QC&#34;]
        self.samples_data_frame = self.percentage_data_frame[self.percentage_data_frame.type == &#34;Analyte&#34;]

    def combine_qc_into_one_data_set_with_highest_recovery_values(self):
        &#34;&#34;&#34;groups the qc_data_frame and creates a new DataFrame with only the highest recoveries for each analyte.

        note: this is different than the best recovery, which is the value closest to 100. Will need to do more work to
        change &#39;highest recovery&#39; to &#39;closest recovery to 100%&#39;. This code was taken from the following StackOverflow
        question: https://stackoverflow.com/questions/31361599. Specifically, the answer given by Padraic Cunningham.&#34;&#34;&#34;

        tem = self.qc_data_frame.groupby([&#39;id17&#39;])[&#39;percrecovery&#39;].transform(max) == self.qc_data_frame[&#39;percrecovery&#39;]
        self.best_recovery_qc_data_frame = self.qc_data_frame[tem]
        self.best_recovery_qc_data_frame.reset_index(drop=True, inplace=True)

    def combine_blanks_into_one_data_set_with_lowest_percentage_concentration_values(self):
        &#34;&#34;&#34; produces a single axis data frame with one min value for each analyte, with the analytes being identified by
        id17 (could also do name20 here). To access the min value for each analyte, use df.iloc[n], with n= row. &#34;&#34;&#34;

        self.min_value_blank_data_frame = self.blank_data_frame.groupby([&#39;id17&#39;])[&#39;percentage_concentration&#39;].min()

    def join_over_curve_df_to_samples_df(self):
        &#34;&#34;&#34; joins the upper limits on areas for given analytes (based on calibration curve) to the samples DataFrame.
        These values are used to assign flags that indicate whether a given peak area is out of calibration range.&#34;&#34;&#34;
        self.samples_data_frame = pd.merge(left=self.samples_data_frame,
                                           right=self.over_curve_data_frame,
                                           how=&#39;left&#39;,
                                           left_on=&#39;id17&#39;,
                                           right_on=&#39;id17&#39;)

    def assign_high_flag_to_sample_data(self):
        &#34;&#34;&#34;assigns a flag to indicate whether a peak area is over the calibration curve range. the over_curve column
        will have a blank string if the area is not over, and will say &#39;over&#39; if the area is over.&#34;&#34;&#34;
        self.samples_data_frame = self.samples_data_frame.assign(over_curve=&#39;&#39;)
        self.samples_data_frame.loc[self.samples_data_frame[&#39;area&#39;] &gt;
                                    self.samples_data_frame[&#39;max_value&#39;],
                                    &#39;over_curve&#39;] = &#39;over&#39;


pre_generate = PreGenerateMainScript(r&#39;T:\ANALYST WORK FILES\Peter\Rover\xml_data_files\data_6.xlsx&#39;)
pre_generate.pre_generate_controller()</code></pre>
</details>
</section>
<section>
</section>
<section>
</section>
<section>
</section>
<section>
<h2 class="section-title" id="header-classes">Classes</h2>
<dl>
<dt id="Rover_Source_Code.Pre_Generate.pre_generate_main_script.PreGenerateMainScript"><code class="flex name class">
<span>class <span class="ident">PreGenerateMainScript</span></span>
<span>(</span><span>data_xml_file)</span>
</code></dt>
<dd>
<section class="desc"><p>This file controls the processes occurring prior to generating latex files. Raw data -&gt; Processed data.</p>
<p>The main init function.</p>
<ol>
<li>data_xml_file = the raw xml data file produced by TargetLynx. This must be manually placed in the datafiles</li>
<li>folder to be read by Rover. The name of it is passed to init.</li>
<li>raw_xml_data_frame = the first DataFrame produced from the xml file. At this point, the data is not
manipulated in any way.</li>
<li>percentage_data_frame = changes: analytical concentration converted to percentage concentration.</li>
<li>blank_data_frame = changes: only information from blanks.</li>
<li>qc_data_frame = changes: only information from standards.</li>
<li>samples_data_frame = changes: only information from samples and their dilutions.</li>
<li>best_recovery_qc_data_frame = changes: all the standard data has been analyzed, and the best recoveries for
each analyte have been selected for the new data frame, which consists of one samples' worth of rows.</li>
<li>min_value_blank_data_frame = changes: one axis data frame with the minimum value of each analyte from the
blank_data_frame.</li>
</ol></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class PreGenerateMainScript:
    &#34;&#34;&#34;This file controls the processes occurring prior to generating latex files. Raw data -&gt; Processed data.&#34;&#34;&#34;

    def __init__(self, data_xml_file):
        &#34;&#34;&#34;The main init function.

        1. data_xml_file = the raw xml data file produced by TargetLynx. This must be manually placed in the datafiles
        2. folder to be read by Rover. The name of it is passed to init.
        3. raw_xml_data_frame = the first DataFrame produced from the xml file. At this point, the data is not
        manipulated in any way.
        4. percentage_data_frame = changes: analytical concentration converted to percentage concentration.
        5. blank_data_frame = changes: only information from blanks.
        6. qc_data_frame = changes: only information from standards.
        7. samples_data_frame = changes: only information from samples and their dilutions.
        8. best_recovery_qc_data_frame = changes: all the standard data has been analyzed, and the best recoveries for
        each analyte have been selected for the new data frame, which consists of one samples&#39; worth of rows.
        9. min_value_blank_data_frame = changes: one axis data frame with the minimum value of each analyte from the
        blank_data_frame.&#34;&#34;&#34;

        self.data_xml_file = data_xml_file
        self.raw_xml_data_frame = pd.DataFrame()
        self.percentage_data_frame = pd.DataFrame()
        self.blank_data_frame = pd.DataFrame()
        self.qc_data_frame = pd.DataFrame()
        self.samples_data_frame = pd.DataFrame()
        self.best_recovery_qc_data_frame = pd.DataFrame()
        self.min_value_blank_data_frame = pd.DataFrame()

#       Range check dictionary - these are the high and low values for our curve. If area is smaller than the first
#       number, or larger than the second one, it is out of range. If that happens, the value needs to be swapped with
#       the corresponding value from the dilution.
        self.range_checker_dictionary = {1: [3065, 44880, &#39;ibuprofen&#39;],
                                         2: [127, 94400, &#39;CBDV&#39;],
                                         3: [64, 16896, &#39;CBDVA&#39;],
                                         4: [259, 103785, &#39;THCV&#39;],
                                         5: [259, 103785, &#39;CBGVA&#39;],  # copying THCV for now
                                         6: [100, 160995, &#39;CBD&#39;],
                                         7: [117, 80956, &#39;CBG&#39;],
                                         8: [100, 170668, &#39;CBDA&#39;],
                                         9: [100, 27050, &#39;CBN&#39;],
                                         10: [100, 22440, &#39;CBGA&#39;],
                                         11: [100, 15440, &#39;THCVA&#39;],
                                         12: [133.9, 203125, &#39;d9_THC&#39;],
                                         13: [163, 84959, &#39;d8_THC&#39;],
                                         14: [86.4, 82725, &#39;CBL&#39;],
                                         15: [100, 14365, &#39;CBC&#39;],
                                         16: [131, 24365, &#39;CBNA&#39;],
                                         17: [100, 170391, &#39;THCA&#39;],
                                         18: [110, 20391, &#39;CBLA&#39;],
                                         19: [100, 12482, &#39;CBCA&#39;]}

#       This DataFrame is so we can join the calibration curve data to the samples DataFrame in order to flag the
#       samples for being over the curve.
        self.over_curve_data = {&#39;id17&#39;: [1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19],
                                &#39;max_value&#39;: [44880, 94400, 16896, 103785, 103785, 160995, 80956, 170668,
                                              27050, 22440, 15440, 203125, 84959, 82725, 14365, 24365,
                                              170391, 20391, 12482]}
        self.over_curve_data_frame = pd.DataFrame(self.over_curve_data, columns=[&#39;id17&#39;, &#39;max_value&#39;])

#       This is for development - allows me to see the full DataFrame when i print to the console, rather than a
#       truncated version. This is useful for debugging purposes and ensuring that methods are working as intended.
        pd.set_option(&#39;display.max_rows&#39;, None)
        pd.set_option(&#39;display.max_columns&#39;, None)
        pd.set_option(&#39;display.width&#39;, None)
        pd.set_option(&#39;display.max_colwidth&#39;, -1)

    def pre_generate_controller(self):
        &#34;&#34;&#34;The main controller function. To run the methods that make up this class, this function is called.&#34;&#34;&#34;

        self.collect_data_from_xml_file()
        self.convert_analytical_concentration_to_percentage_concentration()
        self.split_into_blank_qc_and_sample_data_frame()
        self.combine_qc_into_one_data_set_with_highest_recovery_values()
        self.combine_blanks_into_one_data_set_with_lowest_percentage_concentration_values()
        self.join_over_curve_df_to_samples_df()
        self.assign_high_flag_to_sample_data()

    def collect_data_from_xml_file(self):
        &#34;&#34;&#34;Reads the xml data, saves it to a Pandas DataFrame.

        1. id15: the id in the batch. First standard/blank/sample is 1, second is 2, etc.
        2. sampleid: the sample number, or the name of the standard/blank.
        3. id17: the id of the particular analyte for the row.
        4. name20: the name of the particular analyte for the row.
        5. initamount: the mass, in grams, of the sample.
        6. area: the peak area of the analyte from the chromatogram.
        7. analconc: the concentration calculated by TargetLynx. This will improve after analyst peak integration.
        8. percrecovery: the percentage recovery of ibuprofen.
        9. type: Blank, QC, or analyte.

        there is a try/except statement that will catch an incorrect path/filename.&#34;&#34;&#34;

        try:
            raw_xml_data = pd.read_excel(self.data_xml_file,)
        except FileNotFoundError:
            print(&#34;ERROR: XML FILE NOT FOUND&#34;)
            print(str(self.data_xml_file) + &#34; cannot be found. Either the path to the xml_data_files folder is &#34; +
                  &#34;wrong, or the file doesn&#39;t exist.&#34;)
            print(&#34;SCRIPT EXITING.&#34;)
            sys.exit()
        self.raw_xml_data_frame = pd.DataFrame(raw_xml_data,
                                               columns=[&#39;id15&#39;,
                                                        &#39;sampleid&#39;,
                                                        &#39;id17&#39;,
                                                        &#39;name20&#39;,
                                                        &#39;initamount&#39;,
                                                        &#39;area&#39;,
                                                        &#39;analconc&#39;,
                                                        &#39;percrecovery&#39;,
                                                        &#39;type&#39;]
                                               )

    def convert_analytical_concentration_to_percentage_concentration(self):
        &#34;&#34;&#34;converts the analytical concentration to a percent concentration. Saves as a new DataFrame.&#34;&#34;&#34;

        self.percentage_data_frame = self.raw_xml_data_frame
        self.percentage_data_frame[&#39;percentage_concentration&#39;] = self.percentage_data_frame[&#39;analconc&#39;]/10000

    def split_into_blank_qc_and_sample_data_frame(self):
        &#34;&#34;&#34;splits the percentage DataFrame into blank, qc, and sample DataFrames, based on the &#39;type&#39; column.&#34;&#34;&#34;

        self.blank_data_frame = self.percentage_data_frame[self.percentage_data_frame.type == &#34;Blank&#34;]
        self.qc_data_frame = self.percentage_data_frame[self.percentage_data_frame.type == &#34;QC&#34;]
        self.samples_data_frame = self.percentage_data_frame[self.percentage_data_frame.type == &#34;Analyte&#34;]

    def combine_qc_into_one_data_set_with_highest_recovery_values(self):
        &#34;&#34;&#34;groups the qc_data_frame and creates a new DataFrame with only the highest recoveries for each analyte.

        note: this is different than the best recovery, which is the value closest to 100. Will need to do more work to
        change &#39;highest recovery&#39; to &#39;closest recovery to 100%&#39;. This code was taken from the following StackOverflow
        question: https://stackoverflow.com/questions/31361599. Specifically, the answer given by Padraic Cunningham.&#34;&#34;&#34;

        tem = self.qc_data_frame.groupby([&#39;id17&#39;])[&#39;percrecovery&#39;].transform(max) == self.qc_data_frame[&#39;percrecovery&#39;]
        self.best_recovery_qc_data_frame = self.qc_data_frame[tem]
        self.best_recovery_qc_data_frame.reset_index(drop=True, inplace=True)

    def combine_blanks_into_one_data_set_with_lowest_percentage_concentration_values(self):
        &#34;&#34;&#34; produces a single axis data frame with one min value for each analyte, with the analytes being identified by
        id17 (could also do name20 here). To access the min value for each analyte, use df.iloc[n], with n= row. &#34;&#34;&#34;

        self.min_value_blank_data_frame = self.blank_data_frame.groupby([&#39;id17&#39;])[&#39;percentage_concentration&#39;].min()

    def join_over_curve_df_to_samples_df(self):
        &#34;&#34;&#34; joins the upper limits on areas for given analytes (based on calibration curve) to the samples DataFrame.
        These values are used to assign flags that indicate whether a given peak area is out of calibration range.&#34;&#34;&#34;
        self.samples_data_frame = pd.merge(left=self.samples_data_frame,
                                           right=self.over_curve_data_frame,
                                           how=&#39;left&#39;,
                                           left_on=&#39;id17&#39;,
                                           right_on=&#39;id17&#39;)

    def assign_high_flag_to_sample_data(self):
        &#34;&#34;&#34;assigns a flag to indicate whether a peak area is over the calibration curve range. the over_curve column
        will have a blank string if the area is not over, and will say &#39;over&#39; if the area is over.&#34;&#34;&#34;
        self.samples_data_frame = self.samples_data_frame.assign(over_curve=&#39;&#39;)
        self.samples_data_frame.loc[self.samples_data_frame[&#39;area&#39;] &gt;
                                    self.samples_data_frame[&#39;max_value&#39;],
                                    &#39;over_curve&#39;] = &#39;over&#39;</code></pre>
</details>
<h3>Methods</h3>
<dl>
<dt id="Rover_Source_Code.Pre_Generate.pre_generate_main_script.PreGenerateMainScript.assign_high_flag_to_sample_data"><code class="name flex">
<span>def <span class="ident">assign_high_flag_to_sample_data</span></span>(<span>self)</span>
</code></dt>
<dd>
<section class="desc"><p>assigns a flag to indicate whether a peak area is over the calibration curve range. the over_curve column
will have a blank string if the area is not over, and will say 'over' if the area is over.</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def assign_high_flag_to_sample_data(self):
    &#34;&#34;&#34;assigns a flag to indicate whether a peak area is over the calibration curve range. the over_curve column
    will have a blank string if the area is not over, and will say &#39;over&#39; if the area is over.&#34;&#34;&#34;
    self.samples_data_frame = self.samples_data_frame.assign(over_curve=&#39;&#39;)
    self.samples_data_frame.loc[self.samples_data_frame[&#39;area&#39;] &gt;
                                self.samples_data_frame[&#39;max_value&#39;],
                                &#39;over_curve&#39;] = &#39;over&#39;</code></pre>
</details>
</dd>
<dt id="Rover_Source_Code.Pre_Generate.pre_generate_main_script.PreGenerateMainScript.collect_data_from_xml_file"><code class="name flex">
<span>def <span class="ident">collect_data_from_xml_file</span></span>(<span>self)</span>
</code></dt>
<dd>
<section class="desc"><p>Reads the xml data, saves it to a Pandas DataFrame.</p>
<ol>
<li>id15: the id in the batch. First standard/blank/sample is 1, second is 2, etc.</li>
<li>sampleid: the sample number, or the name of the standard/blank.</li>
<li>id17: the id of the particular analyte for the row.</li>
<li>name20: the name of the particular analyte for the row.</li>
<li>initamount: the mass, in grams, of the sample.</li>
<li>area: the peak area of the analyte from the chromatogram.</li>
<li>analconc: the concentration calculated by TargetLynx. This will improve after analyst peak integration.</li>
<li>percrecovery: the percentage recovery of ibuprofen.</li>
<li>type: Blank, QC, or analyte.</li>
</ol>
<p>there is a try/except statement that will catch an incorrect path/filename.</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def collect_data_from_xml_file(self):
    &#34;&#34;&#34;Reads the xml data, saves it to a Pandas DataFrame.

    1. id15: the id in the batch. First standard/blank/sample is 1, second is 2, etc.
    2. sampleid: the sample number, or the name of the standard/blank.
    3. id17: the id of the particular analyte for the row.
    4. name20: the name of the particular analyte for the row.
    5. initamount: the mass, in grams, of the sample.
    6. area: the peak area of the analyte from the chromatogram.
    7. analconc: the concentration calculated by TargetLynx. This will improve after analyst peak integration.
    8. percrecovery: the percentage recovery of ibuprofen.
    9. type: Blank, QC, or analyte.

    there is a try/except statement that will catch an incorrect path/filename.&#34;&#34;&#34;

    try:
        raw_xml_data = pd.read_excel(self.data_xml_file,)
    except FileNotFoundError:
        print(&#34;ERROR: XML FILE NOT FOUND&#34;)
        print(str(self.data_xml_file) + &#34; cannot be found. Either the path to the xml_data_files folder is &#34; +
              &#34;wrong, or the file doesn&#39;t exist.&#34;)
        print(&#34;SCRIPT EXITING.&#34;)
        sys.exit()
    self.raw_xml_data_frame = pd.DataFrame(raw_xml_data,
                                           columns=[&#39;id15&#39;,
                                                    &#39;sampleid&#39;,
                                                    &#39;id17&#39;,
                                                    &#39;name20&#39;,
                                                    &#39;initamount&#39;,
                                                    &#39;area&#39;,
                                                    &#39;analconc&#39;,
                                                    &#39;percrecovery&#39;,
                                                    &#39;type&#39;]
                                           )</code></pre>
</details>
</dd>
<dt id="Rover_Source_Code.Pre_Generate.pre_generate_main_script.PreGenerateMainScript.combine_blanks_into_one_data_set_with_lowest_percentage_concentration_values"><code class="name flex">
<span>def <span class="ident">combine_blanks_into_one_data_set_with_lowest_percentage_concentration_values</span></span>(<span>self)</span>
</code></dt>
<dd>
<section class="desc"><p>produces a single axis data frame with one min value for each analyte, with the analytes being identified by
id17 (could also do name20 here). To access the min value for each analyte, use df.iloc[n], with n= row.</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def combine_blanks_into_one_data_set_with_lowest_percentage_concentration_values(self):
    &#34;&#34;&#34; produces a single axis data frame with one min value for each analyte, with the analytes being identified by
    id17 (could also do name20 here). To access the min value for each analyte, use df.iloc[n], with n= row. &#34;&#34;&#34;

    self.min_value_blank_data_frame = self.blank_data_frame.groupby([&#39;id17&#39;])[&#39;percentage_concentration&#39;].min()</code></pre>
</details>
</dd>
<dt id="Rover_Source_Code.Pre_Generate.pre_generate_main_script.PreGenerateMainScript.combine_qc_into_one_data_set_with_highest_recovery_values"><code class="name flex">
<span>def <span class="ident">combine_qc_into_one_data_set_with_highest_recovery_values</span></span>(<span>self)</span>
</code></dt>
<dd>
<section class="desc"><p>groups the qc_data_frame and creates a new DataFrame with only the highest recoveries for each analyte.</p>
<p>note: this is different than the best recovery, which is the value closest to 100. Will need to do more work to
change 'highest recovery' to 'closest recovery to 100%'. This code was taken from the following StackOverflow
question: <a href="https://stackoverflow.com/questions/31361599.">https://stackoverflow.com/questions/31361599.</a> Specifically, the answer given by Padraic Cunningham.</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def combine_qc_into_one_data_set_with_highest_recovery_values(self):
    &#34;&#34;&#34;groups the qc_data_frame and creates a new DataFrame with only the highest recoveries for each analyte.

    note: this is different than the best recovery, which is the value closest to 100. Will need to do more work to
    change &#39;highest recovery&#39; to &#39;closest recovery to 100%&#39;. This code was taken from the following StackOverflow
    question: https://stackoverflow.com/questions/31361599. Specifically, the answer given by Padraic Cunningham.&#34;&#34;&#34;

    tem = self.qc_data_frame.groupby([&#39;id17&#39;])[&#39;percrecovery&#39;].transform(max) == self.qc_data_frame[&#39;percrecovery&#39;]
    self.best_recovery_qc_data_frame = self.qc_data_frame[tem]
    self.best_recovery_qc_data_frame.reset_index(drop=True, inplace=True)</code></pre>
</details>
</dd>
<dt id="Rover_Source_Code.Pre_Generate.pre_generate_main_script.PreGenerateMainScript.convert_analytical_concentration_to_percentage_concentration"><code class="name flex">
<span>def <span class="ident">convert_analytical_concentration_to_percentage_concentration</span></span>(<span>self)</span>
</code></dt>
<dd>
<section class="desc"><p>converts the analytical concentration to a percent concentration. Saves as a new DataFrame.</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def convert_analytical_concentration_to_percentage_concentration(self):
    &#34;&#34;&#34;converts the analytical concentration to a percent concentration. Saves as a new DataFrame.&#34;&#34;&#34;

    self.percentage_data_frame = self.raw_xml_data_frame
    self.percentage_data_frame[&#39;percentage_concentration&#39;] = self.percentage_data_frame[&#39;analconc&#39;]/10000</code></pre>
</details>
</dd>
<dt id="Rover_Source_Code.Pre_Generate.pre_generate_main_script.PreGenerateMainScript.join_over_curve_df_to_samples_df"><code class="name flex">
<span>def <span class="ident">join_over_curve_df_to_samples_df</span></span>(<span>self)</span>
</code></dt>
<dd>
<section class="desc"><p>joins the upper limits on areas for given analytes (based on calibration curve) to the samples DataFrame.
These values are used to assign flags that indicate whether a given peak area is out of calibration range.</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def join_over_curve_df_to_samples_df(self):
    &#34;&#34;&#34; joins the upper limits on areas for given analytes (based on calibration curve) to the samples DataFrame.
    These values are used to assign flags that indicate whether a given peak area is out of calibration range.&#34;&#34;&#34;
    self.samples_data_frame = pd.merge(left=self.samples_data_frame,
                                       right=self.over_curve_data_frame,
                                       how=&#39;left&#39;,
                                       left_on=&#39;id17&#39;,
                                       right_on=&#39;id17&#39;)</code></pre>
</details>
</dd>
<dt id="Rover_Source_Code.Pre_Generate.pre_generate_main_script.PreGenerateMainScript.pre_generate_controller"><code class="name flex">
<span>def <span class="ident">pre_generate_controller</span></span>(<span>self)</span>
</code></dt>
<dd>
<section class="desc"><p>The main controller function. To run the methods that make up this class, this function is called.</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def pre_generate_controller(self):
    &#34;&#34;&#34;The main controller function. To run the methods that make up this class, this function is called.&#34;&#34;&#34;

    self.collect_data_from_xml_file()
    self.convert_analytical_concentration_to_percentage_concentration()
    self.split_into_blank_qc_and_sample_data_frame()
    self.combine_qc_into_one_data_set_with_highest_recovery_values()
    self.combine_blanks_into_one_data_set_with_lowest_percentage_concentration_values()
    self.join_over_curve_df_to_samples_df()
    self.assign_high_flag_to_sample_data()</code></pre>
</details>
</dd>
<dt id="Rover_Source_Code.Pre_Generate.pre_generate_main_script.PreGenerateMainScript.split_into_blank_qc_and_sample_data_frame"><code class="name flex">
<span>def <span class="ident">split_into_blank_qc_and_sample_data_frame</span></span>(<span>self)</span>
</code></dt>
<dd>
<section class="desc"><p>splits the percentage DataFrame into blank, qc, and sample DataFrames, based on the 'type' column.</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def split_into_blank_qc_and_sample_data_frame(self):
    &#34;&#34;&#34;splits the percentage DataFrame into blank, qc, and sample DataFrames, based on the &#39;type&#39; column.&#34;&#34;&#34;

    self.blank_data_frame = self.percentage_data_frame[self.percentage_data_frame.type == &#34;Blank&#34;]
    self.qc_data_frame = self.percentage_data_frame[self.percentage_data_frame.type == &#34;QC&#34;]
    self.samples_data_frame = self.percentage_data_frame[self.percentage_data_frame.type == &#34;Analyte&#34;]</code></pre>
</details>
</dd>
</dl>
</dd>
</dl>
</section>
</article>
<nav id="sidebar">
<h1>Index</h1>
<div class="toc">
<ul></ul>
</div>
<ul id="index">
<li><h3>Super-module</h3>
<ul>
<li><code><a title="Rover_Source_Code.Pre_Generate" href="index.html">Rover_Source_Code.Pre_Generate</a></code></li>
</ul>
</li>
<li><h3><a href="#header-classes">Classes</a></h3>
<ul>
<li>
<h4><code><a title="Rover_Source_Code.Pre_Generate.pre_generate_main_script.PreGenerateMainScript" href="#Rover_Source_Code.Pre_Generate.pre_generate_main_script.PreGenerateMainScript">PreGenerateMainScript</a></code></h4>
<ul class="">
<li><code><a title="Rover_Source_Code.Pre_Generate.pre_generate_main_script.PreGenerateMainScript.assign_high_flag_to_sample_data" href="#Rover_Source_Code.Pre_Generate.pre_generate_main_script.PreGenerateMainScript.assign_high_flag_to_sample_data">assign_high_flag_to_sample_data</a></code></li>
<li><code><a title="Rover_Source_Code.Pre_Generate.pre_generate_main_script.PreGenerateMainScript.collect_data_from_xml_file" href="#Rover_Source_Code.Pre_Generate.pre_generate_main_script.PreGenerateMainScript.collect_data_from_xml_file">collect_data_from_xml_file</a></code></li>
<li><code><a title="Rover_Source_Code.Pre_Generate.pre_generate_main_script.PreGenerateMainScript.combine_blanks_into_one_data_set_with_lowest_percentage_concentration_values" href="#Rover_Source_Code.Pre_Generate.pre_generate_main_script.PreGenerateMainScript.combine_blanks_into_one_data_set_with_lowest_percentage_concentration_values">combine_blanks_into_one_data_set_with_lowest_percentage_concentration_values</a></code></li>
<li><code><a title="Rover_Source_Code.Pre_Generate.pre_generate_main_script.PreGenerateMainScript.combine_qc_into_one_data_set_with_highest_recovery_values" href="#Rover_Source_Code.Pre_Generate.pre_generate_main_script.PreGenerateMainScript.combine_qc_into_one_data_set_with_highest_recovery_values">combine_qc_into_one_data_set_with_highest_recovery_values</a></code></li>
<li><code><a title="Rover_Source_Code.Pre_Generate.pre_generate_main_script.PreGenerateMainScript.convert_analytical_concentration_to_percentage_concentration" href="#Rover_Source_Code.Pre_Generate.pre_generate_main_script.PreGenerateMainScript.convert_analytical_concentration_to_percentage_concentration">convert_analytical_concentration_to_percentage_concentration</a></code></li>
<li><code><a title="Rover_Source_Code.Pre_Generate.pre_generate_main_script.PreGenerateMainScript.join_over_curve_df_to_samples_df" href="#Rover_Source_Code.Pre_Generate.pre_generate_main_script.PreGenerateMainScript.join_over_curve_df_to_samples_df">join_over_curve_df_to_samples_df</a></code></li>
<li><code><a title="Rover_Source_Code.Pre_Generate.pre_generate_main_script.PreGenerateMainScript.pre_generate_controller" href="#Rover_Source_Code.Pre_Generate.pre_generate_main_script.PreGenerateMainScript.pre_generate_controller">pre_generate_controller</a></code></li>
<li><code><a title="Rover_Source_Code.Pre_Generate.pre_generate_main_script.PreGenerateMainScript.split_into_blank_qc_and_sample_data_frame" href="#Rover_Source_Code.Pre_Generate.pre_generate_main_script.PreGenerateMainScript.split_into_blank_qc_and_sample_data_frame">split_into_blank_qc_and_sample_data_frame</a></code></li>
</ul>
</li>
</ul>
</li>
</ul>
</nav>
</main>
<footer id="footer">
<p>Generated by <a href="https://pdoc3.github.io/pdoc"><cite>pdoc</cite> 0.7.4</a>.</p>
</footer>
<script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/highlight.min.js"></script>
<script>hljs.initHighlightingOnLoad()</script>
</body>
</html>